<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Seattle JS Meetup - Socket.IO</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
					<h2> Seattle JS Meetup</h2>
					<image class="fragment roll-in" width='500' src='http://cdn.meme.am/instances/500x/56162754.jpg'>
					<aside class="notes">
				     Thank you. First of all, thanks everyone for coming to Moz. We are really glad to have the
				     opportunity to host this seattle JS Meetup.
				    </aside>
				</section>

				<section>
					<h1> SOCKET.IO </h1>
					<h3> Using websockets in your everyday project!</h3>
					<p>
						<small>Created by <a href="http://www.linkedin.com/in/ramonrecuero/">Ramon Recuero</a> / <a href="http://twitter.com/ramonrecuero">@ramonrecuero</a></small>
						<small>& <a href="https://www.linkedin.com/profile/view?id=2668223&authType=NAME_SEARCH&authToken=qJnh&locale=en_US&trk=tyah2&trkInfo=tarId%3A1415762890592%2Ctas%3Aandreas%2Cidx%3A1-2-2">Andreas Heim</a> / <a href="http://twitter.com/andreas">@andreas</a></small>
					</p>
					<aside class="notes">
				      My name is Ramon. Me and Andreas are going to talk about Socket.io, what is it, what can it be used for and we'll give you a real example of how we use it here at Moz.
				    </aside>
				</section>

				<section>
					<h1>What is Socket.IO?</h1>
					<iframe src="http://weplay.io" width="100%" height="480" scrolling="no" class=" fragment iframe-class" frameborder="0"></iframe>
					<aside class="notes">
						Socket.io is a real time engine based on Web Sockets that allows you build event-based services. You don't need to use long polling or fire multiple AJAX requests per second any more.

						Probably, you have heard about Socket.io and seen how to use it in sexy applications like chat services, binary streaming or even in a recreation of Pok√©mon.

						This all looks really cool, but now you may be wondering how you can use socket.io in my project. I am going to try to give you some pointers as to when you can use it.
				    </aside>
				</section>

				<section>
					<h2> 1 - Request/Response?</h2>
					<image class="fragment roll-in" width='500' src='http://www.pubnub.com/blog/wp-content/uploads/2013/09/WebSockets2.png'>
					<ul class="fragment roll-in" >
						<li class="fragment roll-in"> Logging </li>
						<li class="fragment roll-in"> Click Tracking </li>
						<li class="fragment roll-in"> Loading bars or spinners </li>
					</ul>
					<aside class="notes">
						Firstly, Socket.io would be the perfect tool to use when you don't require a request/response format. As long as the WebSocket connection is open, you can send messages with a small overhead. What kind of service that all of us use fits this situation?
				    Let me give you a couple examples. For example, you are sending client logs to your server or messages every time the user clicks something but you don't need any response back.

						- Client logging
						- Analytics.
						- Loading bars or spinners.
				  </aside>
				</section>
				<section>
					<h2> 2 - Sporadic Server Push</h2>
					<ul class="fragment roll-in" >
						<li class="fragment roll-in"> In app messages </li>
						<li class="fragment roll-in"> Notifications </li>
					</ul>
					<div class='fragment' width='100%'>
						<img width='500' src="http://assets.diylol.com/hfs/36b/953/478/resized/x-x-everywhere-meme-generator-notifications-notifications-everywhere-5982f8.jpg" alt="Colons">
				  </div>
					<aside class="notes">
						2. Another use case is when you need a server to contact a client sporadically.
						For a long time, you have probably used long polling or tools like Comet to simulate a server push.
						Luckily, those times are over.
						This is perfect for situtations where an asynchronous event happens and you want to refresh the web client. A perfect example would be the in app notification or messages that apps like LinkedIn,
						Facebook or twitter do and that we all love.
				    </aside>
				</section>
				<section>
					<h2> Sockets at Moz</h2>
					<img src="http://i.imgur.com/TlDk18l.png" alt="Colons">
					<aside class="notes">
						As you may know, here at Moz we have web crawlers that crawl the website and return the information once the whole crawl is done. In this case, our test crawl sends you an email once is finished.

						We realised that the users don't want to trigger a crawl and then just get the results when everything is complete, they want real time feedback
						that they can use to optimize their marketing efforts.

						Here is where socket.Io comes into play. We use socket.IO to receive crawl messages the exact moment they happen and refresh the UI as soon as we get those messages.

						For example, we receive a new 500 error and it apepars automatically, 404, 300...
				    </aside>
				</section>
				<section>
					<img width='500' src="http://i.imgur.com/NHVlkbl.jpg" alt="Colons">
					<aside class="notes">
						Now, Andreas is going to explain the solution and details about the implementation.
				   </aside>
				</section>
				<section>
					<h2>Architecture</h2>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h2>Demo</h2>
					<a href="https://local.moz.com:3000/crawler/overview" target="_blank"><img src="images/crawler_demo.png" alt="Crawler Demo"></a>
					<aside class="notes">
					</aside>
				</section>
				<section>
					<h2>Client Side Setup</h2>
					<pre><code data-trim>
@socket = io()
@socket.on 'crawlResults', (msg) => @processCrawlResults msg
@socket.emit 'openCrawl',
  url: @get 'url'
  clientId: @get 'id'
					</code></pre>
					<aside class="notes">
						socket.io makes it very simple, removes just about all of the boilerplate you would otherwise need.
						And it has a fallback in case your browser doesn't support websockets yet.

						3 simple steps:
							- connect to the server
							- listen for any messages you expect just like regular event handlers
							- open a connection by sending a message

					</aside>
				</section>
				<section>
					<h2>Server Side Setup</h2>
					<pre><code data-trim>
# Websocket
server.app.io.on 'connection', (socket) ->
  clients.addConnection socket

# Clients class
addConnection: (socket) ->
  socket.on 'disconnect', => @removeConnection socket
  socket.on 'openCrawl', (args) => @openCrawl socket, args

onCrawlResult: (msg) ->
  @socket.emit 'crawlResults', msg
					</code></pre>
					<aside class="notes">
						Similar simple setup:
							- handle opening a connection
							- make sure to handle disconnection
							- provide the api for the client
							- send data back to the client
					</aside>
				</section>
				<section>
					<h2>Questions?</h2>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
